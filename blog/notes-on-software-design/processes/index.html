<!DOCTYPE html><html><head> <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png"><link rel="manifest" href="/icons/site.webmanifest"><link rel="shortcut icon" href="/icons/favicon.ico"><meta name="msapplication-TileColor" content="#603cba"><meta name="msapplication-config" content="/icons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="--WV6qAuzU9GnL3462uvvFCGbyR8jm9J0YzYWMWQ1IU"><title>Processes of Decomposition ‚Ä¢ joshsj</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><link rel="stylesheet" href="/styles/variables.css"><link rel="stylesheet" href="/styles/utilities.css"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/layout.css"><link rel="stylesheet" href="/styles/components.css"><link rel="stylesheet" href="/styles/lib.css"><script src="/scripts/theme.js" defer></script><script src="/scripts/myEmail.js" defer></script><script src="/scripts/id-jumper.js" defer></script><script src="/scripts/konami.js" defer></script></head><body>   <nav><a href="/">Home</a><a href="/blog/">Blog</a><a href="/collections/">Collections</a><a href="/portfolio/">Portfolio</a><button class="link" id="theme-toggle" aria-hidden="" aria-role="Toggle for light/dark theme"></button></nav><main class="content"><h1>Processes of Decomposition</h1><p>Posted on November 22nd, 2021</p><p class="squish">Part of <a href="/collections/"> Notes on Software Design</a></p><p>The design of a system outlines what the system is and is not for, describes the
overall architecture following which the system will be developed, and details
its static structure and dynamic behaviour.</p><p>At this point, we have some amount of user profiles/personas, scenarios,
storyboards, wireframes, and (non-)functional requirements. We can now
start<!-- excerpt-->decomposing the system concept into a theoretical
representation.<!-- excerpt--></p><p>Documenting the design should be done various levels of complexity/abstraction.
Without simplification, the design process would be trivial since it would match
the implementation identically.</p><p><em>Functional design</em> concentrates on the functionality of the system, whereas
<em>operational Design</em> concentrates on the operational aspects; e.g., hardware set-up, what functionality runs
where, network design. With the movement in modern software development towards the cloud, this is becoming less
relevant.</p><p>Good design addresses and includes extensibility, modularity, reusability,
maintainability, usability, and clarity.</p><h2>Balance for all involved</h2><p>When designing an application, a requirement will have many possible design
solutions; the users, developers, and maintainers must all be considered, as an
imbalance will lead to detriment for everyone.</p><p>For example, over-simplified applications will be easier to create but the
end-user will not be happy with the system</p><p>By contrast, complex systems will be harder to develop and maintain; this costs
time and money which ultimately affects the end-user.</p><h2>Using patterns</h2><p>Most 'new' solutions are simply an adaptation of existing applications, so the
wheel need not be reinvented. More importantly, use design patterns which are
relevant to the solution. e.g., N-tier or lter for a .NET API written with C#.</p><p>Design patterns also accommodate for changes and maintenance, as new designers
will have a fundamental understanding of the system before tacking domain
knowledge, implementation, etc.</p><h2>Representation</h2><p>Designs should be represented with models because they're a proven and
well-accepted method.</p><p>They should demonstrate the functionality of the system at different levels of
complexity/abstraction. This makes the design more accessible, as the system can
be understood at the level desired by an individual. Inherently, it is important
to ensure a representation is not oversimplified or important details may be
masked.</p><p>Provided the developers of the system respect the design, a system's model will
closely resemble the technical implementation of the system, so getting the
models correct is key to smooth development.</p><h2>Making Decisions</h2><p>Although some aspects of the solution will have a clearly optimal design, most
aspects of a project will require some level of decision-making.</p><p>As such, it is important to document any/all decisions. Not only does it simply
provide evidence of the decisions made by the team, but producing a standardized
document ensures all factors motivating the decision are valid.</p><figure><div class="inner"><table><thead><tr><th>Decision</th><th>[ID] - [Name]</th></tr></thead><tbody><tr><td>Subject Area</td><td>Area of concern</td></tr><tr><td>Topic</td><td>Topic of interest</td></tr><tr><td>Summary</td><td>Summary of the decision made, ideally in the imperative tense</td></tr><tr><td>Problem Statement</td><td>A short description of the problem, i.e., what is being decided</td></tr><tr><td>Assumptions</td><td>What is believed to be true about the context of the problem</td></tr><tr><td>Motivation</td><td>Why is the decision important?</td></tr><tr><td>Alternatives</td><td>A list of alternatives and explanations</td></tr><tr><td>Decision</td><td>The decision taken, possibly with references to related work</td></tr><tr><td>Justification</td><td>Why the decision was made</td></tr><tr><td>Implications</td><td>What impact the decision will have</td></tr><tr><td>Justification</td><td>A list of requirements that are generated by this problem</td></tr><tr><td>Implications</td><td>A list of related decisions</td></tr></tbody></table></div><figcaption>Example Decision Template</figcaption></figure><h2>System Boundary</h2><p>(This is not well explained; most of this is my interpretation so it might be
wrong ü§∑‚Äç‚ôÇÔ∏è)</p><p>A <em>system boundary</em> determines where aspects of the system are sourced by decomposing the top-level
functionality of the solution; basically:</p><ul><li>What is the purpose of the system?</li><li>What the system does not do</li><li>What are the external dependencies?</li></ul><p>Think of it as an extension of scope; after defining what the system should do,
the system boundary determines whether each aspect of the system is 'in scope'
for creation or resourced from an existing solution.</p><p>System boundary also considers human sources for input/output, so these devices
should be considered as well, e.g., PIN number entry pad.</p><p>Lastly, <em>system environment</em> refers to anything which affects/can be affected by the system, excluding the
system itself.
</p><h3>Representation</h3><p>A <em>system context diagram</em>is the typical way to represent the system boundary,
represented as a simple, 'free form' sketch. The relationships between systems
can be ambiguous and considers:</p><ul><li>Who/what is interacting with the target system?</li><li>What are they doing and how?</li></ul><figure><div class="inner"><img src="system context diagram.png"></div><figcaption>System Context Diagram</figcaption></figure><h2>Solution Structure</h2><p>Following the system boundary, the <em>solution structure</em>identifies the main
conceptual elements (subsystems) of the system and their relationships; e.g.,
the core subsystem, connections, data stores, users, external systems, etc.</p><p>Think about:</p><ul><li>How the system will be accessed?</li><li>What are the main conceptual elements?</li><li>How the elements communicate with each other?</li></ul><h3>Representation</h3><p>An <em>architecture overview diagram</em>is the typical way to represent solution
structure. It is a (usually) static, informal diagram with supporting text.</p><p>The definition is pretty loose, so they can identify a wide range of subsystems.
However, there are some typical organisational groupings: users help to identify
the roles of people using the system; channels identify how the system can be
used/accessed, e.g., Browser, Mobile, Integrated PoS terminal; application
identifies the subsystems; and resources contain the systems used by the
application. Additionally, splitting the groups further or color-coding can add
more detail.</p><p>It does not need to be implementation-specific, i.e., 'Database' could be
sufficient, but 'AWS Cloud Hosting' is also acceptable.</p><figure><div class="inner"><img src="architecture overview diagram.png"></div><figcaption>Architecture Overview Diagram</figcaption></figure><h2>Refinement</h2><p>Following the <em>solution structure</em>, the application's subsystems are iteratively
(and recursively) designed in the refinement process:</p><ul><li>How can the conceptual elements be subdivided into subsystems?</li><li>How do the subsystems look like?</li><li>How do the subsystems interact with each other functionally?</li></ul><h3>Types of Subsystems</h3><p>The definition of a subsystem is very flexible but it basically has to be
sizeable. For example, look at the subsystems for a remote control:</p><ol><li>Case</li><li>Power supply</li><li>Circuit board<ol><li>Chips</li><li>Fuses</li><li>IR blaster</li><li>Integrated circuits<ol><li>Capacitors</li><li>Resistors</li><li>Bridges</li></ol></li></ol></li></ol><p>There are however some very common subsystem types.</p><p><span role="heading">Component</span>A modular unit of functionality, usually identified the architecture definition.</p><p>Its state and operations are declared using one or more interfaces, so the
definition should not be implementation specific.</p><p>They are functionally independent, meaning they do one thing.</p><p>Components are defined at a technical level, e.g., <code>MessageQueue</code>, or application level, e.g.,
<code>OrderProcessor</code>.</p><p><span role="heading">Class</span>
The usual.</p><p><span role="heading">Entity</span>
A class with a conceptualisable existence, most often physical like a <code>Person</code>, or not, like a
<code>Report</code> (value objects say huh?).</p><p><span role="heading">Service</span>A group of specifications, exposed through JSON, API, interfaces, etc.</p><p>They can be consumed, e.g., <code>StockPriceService</code>, <code>UserAuthoriser</code>, or provided using components/classes.
</p><h3>It's all about the process</h3><p>Generally, this process considers the structure of each subsystem, and how they
interact.</p><p>Start with <strong>identification</strong> of the subsystems, and assign responsibility, based on the requirements document.
 Define the relationships between subsystems and outline their interactions. Use existing design/architecture
 patterns to ensure the system interactions are clean and consistent.</p><p>Next comes <strong>specification</strong>, which tackles implementation detail by creating the interfaces for each
subsystem. This includes their operations, i.e., parameters, return values; and their contract behaviour, such as
pre- and post-conditions.
</p><h3>Guidelines</h3><p><span role="heading">Cohesion</span>
The strength of dependency <strong>within</strong> the system. The goal is to create functionally independent but
interdependent subsystems, meaning each subsystem has one responsibility and utilises other subsystems to delegate
other responsibilities required to function.</p><p>‚ùå Low cohesion means a subsystem's functionalities have no meaningful
relationship, only in time, i.e., a process may use them in the same block of
code.</p><p>‚úîÔ∏è High cohesion means the opposite. For example, the functionalities can use
each other (functional), use the output of one as an input for another
(sequential), or compose a greater procedure to be used in order (procedural).</p><p><span role="heading">Coupling</span>
The strength of dependencies <strong>between</strong> subsystems. Good coupling allows dependencies to change their
implementation without requiring changes to its dependants.</p><p>‚ùå Strong coupling means subsystems refer to the same global data 'area' and the
internal logic of the subsystem cannot be isolated from the implementation of
its subsystems.</p><p>‚úîÔ∏è Loose coupling the logic between subsystems to be isolated, and communication
is handled with fundamental data types like domain entities or technical
classes.</p><p><span role="heading">Isolation</span>
The degree to which the product depends on
technologies. It also considers recognisability of its design and
implementation.</p><p>‚ùå Low isolation means subsystems depend on technologies, such as a native app;
and fail to use standard patterns, e.g., directing with a database directly.</p><p>‚úîÔ∏è High isolation means the opposite, e.g., a web app (any platform) which uses
an ORM to omit database specifics from the application code.</p><p><span role="heading">Layering</span>
Partitioning the concerns/responsibilities
of a large subsystem into general categories.</p><p>ü§∑‚Äç‚ôÇÔ∏è Horizontal layering categorises by functional responsibility, e.g.,
presentation, business, and data layer. This is referred to N-tier architecture.</p><p>ü§∑‚Äç‚ôÇÔ∏è Vertical layering categorises by business/domain responsibility, e.g., a
query, handler, and view model to<code>CreateProduct</code>. One example is onion
architecture.</p><h3>Types of Models</h3><p><span role="heading">Static models</span>
A static, logical view of the
application including state and relationships (e.g., entity relationship, class,
component, service model).</p><p><span role="heading">Dynamic models</span>
(or behavioural models) demonstrate the interactions between the subsystems (e.g., use-case diagram, sequence
diagrams).</p><p>End-user interactions are modelled with
<a href="/notes-on-software-design/requirements/#Use-Cases">use-case diagrams</a>.</p><p>Technical interactions within a subsystem show the complex behaviours of the
implementation like method and service calls, modelled with flowcharts or
activity diagrams.</p><p>Modelling between systems is captured with interactions models: when ordered by
time, a sequence diagram; when ordered by organization, collaboration or
communication diagrams.</p></main></body></html>