<!DOCTYPE html><html><head> <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png"><link rel="manifest" href="/icons/site.webmanifest"><link rel="shortcut icon" href="/icons/favicon.ico"><meta name="msapplication-TileColor" content="#603cba"><meta name="msapplication-config" content="/icons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="--WV6qAuzU9GnL3462uvvFCGbyR8jm9J0YzYWMWQ1IU"><title>Defining Requirements • joshsj</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><link rel="stylesheet" href="/styles/variables.css"><link rel="stylesheet" href="/styles/utilities.css"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/layout.css"><link rel="stylesheet" href="/styles/components.css"><link rel="stylesheet" href="/styles/lib.css"><script src="/scripts/theme.js" defer></script><script src="/scripts/myEmail.js" defer></script><script src="/scripts/id-jumper.js" defer></script><script src="/scripts/konami.js" defer></script></head><body>   <nav><a href="/">Home</a><a href="/blog/">Blog</a><a href="/collections/">Collections</a><a href="/portfolio/">Portfolio</a><button class="link" id="theme-toggle" aria-hidden="" aria-role="Toggle for light/dark theme"></button></nav><main class="content"><h1>Defining Requirements</h1><p>Posted on November 6th, 2021</p><p class="squish">Part of <a href="/collections/"> Notes on Software Design</a></p><p>The requirements for a software application are affected by its purpose, focus,
and stakeholders.</p><!-- more--><p>Starting with purpose, think very generally: are we (helping to) solve a
business, scientific, or technical problem?</p><p>From its purpose, the focus of the overall application can be considered:</p><ul><li>Data<ul><li>Traditional database-oriented systems</li><li>Normal for business applications</li></ul></li><li>Engagement<ul><li>Decentralised systems which integrate together</li><li>Facilitate and orchestrate the user's experience</li><li>Seamless interaction between each other, e.g., Facebook/Instagram cross-over</li><li>Social media platforms for example</li></ul></li><li>Insight<ul><li>Support for customer experience through consumption, collection, and
analysis of data</li><li>Gathered from data- and engagement-focused systems</li></ul></li></ul><p>From its focus, the role required within its creation team can also be
considered:</p><ul><li>Technical<ul><li>System architect</li><li>Designer</li><li>Developer</li><li>Tester;</li></ul></li><li>Business<ul><li>Business analyst</li><li>Domain experts</li></ul></li><li>Management<ul><li>Project managers</li><li>Programme managers</li><li>Team leaders</li></ul></li></ul><p>Lastly, its stakeholders can further influence its requirements; an application
with an outsourced maintenance team needs to be securely & safely maintainable
by an outsider by design.</p><h2>Sources</h2><p>The requirements for an application may be a solution; in the business world, it
could be an entire aspect of the system as a whole like data analytics. This
also applies at a lower level, e.g., persisting data could be implemented using
a database or configuration files.</p><figure><div class="inner"><img src="requirement sources.png"></div><figcaption>Requirement Sources Diagram</figcaption></figure><h2>Functional Requirements</h2><p>These describe what is solved by the application, i.e, the point of the software. Descriptions can be from a
number of perspectives, ideally <a href="/notes-on-software-design/analysis/#Personas">personas</a>, to address
five main aspects...</p><p><strong>How</strong> &mdash; the business functionality</p><ul><li>What the system has to do under-the-hood</li><li>Captured directly, e.g., with a use-case model</li><li>Captured indirectly, e.g., with a business process model</li></ul><p><strong>Who</strong> &mdash; its users</p><ul><li>How competent are they?</li><li>Do they have accessibility requirements?</li><li>(Personas may also define these requirements)</li></ul><p><strong>Where</strong> &mdash; its users in a context</p><ul><li>How do the they access it? Browsers? Mobile app?</li></ul><p><strong>What</strong> &mdash; the data</p><ul><li>Does the system store all information itself?</li><li>Is any data resourced from elsewhere?</li></ul><p><strong>With</strong> &mdash; integrations</p><ul><li>What the system has to do with other systems</li><li>IT , e.g., a payment gateway for an ATM</li><li>Human, e.g., a user-friendly input device for PINs</li></ul><h2>Non-Functional Requirements</h2><p>Non-function requirements consider everything else; think expectations of usage,
characteristics.</p><h3>Constraints</h3><p>Non-functional requirements which cannot be changed.</p><p><em>Technical constraints</em> are self-explanatory. For example, a project for a large organisation replacing a
legacy system would need to be compatible with their deployment platform(s); the new system can demand a new
deployment mechanism.</p><ul><li>Legacy Integration</li><li>Development Skills</li><li>Existing Infrastructure</li><li>IT Standards</li><li>Implementation Constraints</li></ul><p><em>Business constraints</em> are real-word factors which effect the creation of the solution. Differences in data
protection regulations between countries will determine how the data must be secured.</p><ul><li>Time</li><li>Resource</li><li>Scope</li><li>Risk Willingness</li><li>Regulatory</li><li>Geographic</li><li>Organizational</li></ul><h2>Qualities</h2><p>Expectations of the application. Quality requirements will be appear similar to
constraints, but they are negotiable by-nature.</p><p>Qualities may be drafted from the usage-context of the application (implicit),
like performance. They may also be provided by the customer/stakeholder
(explicit).</p><p><em>Runtime qualities</em> (or <em>observable qualities</em>) provide a value to the user,
meaning they can be empirically tested. Is the system <strong>actually</strong> available 24/7? Are page loads quick?</p><ul><li>Performance: without this, users won't be able to use the system</li><li>Capacity</li><li>Availability: without this, users will stop using the system</li><li>Security: without this, 'users' will stop the system being used</li><li>Systems Management</li><li>Usability</li><li>Accessibility</li></ul><p><em>Non-runtime qualities</em> (or <em>unobservable qualities</em>) cannot be measured easily. For example, disaster
management: it's quite hard, and fairly immoral, to simulate an earthquake.</p><ul><li>Portability</li><li>Maintainability</li><li>Manageability</li><li>Scalability</li><li>Data Integrity</li><li>Environmental</li><li>Efficiency</li><li>Reliability</li></ul><h2>Documentation</h2><p>Firstly, some rules of thumb:</p><ul><li>Use complete sentences</li><li>Identify requirements with a unique reference, e.g, ID</li><li>Be clear, concise, and explicit (avoid ambiguity, jargon)</li><li>Do not make false promises, e.g., <em>"100% reliable"</em></li><li>Define success/acceptance criteria</li><li>Ensure they are measurable and testable</li><li>Reference supporting material, instead of duplicating information</li></ul><h3>Phrasing</h3><p>The M.O.S.C.O.W acronym helps with phrasing a requirement. I still don't know
where the first 'O' comes from.</p><ul><li>'Shall', 'Will', and 'Must' indicate mandatory requirements</li><li>'Should' and 'Might' indicate optional requirements</li><li>'Could' indicates desirable requirements</li></ul><h3>Guideline</h3><p>The S.M.A.R.T mnemonic helps to ensure all information for a requirement is
provided. Lets start with a basic, undeveloped requirement:</p><blockquote><p>The system should allow a visually impaired elderly person to upload health
parameters.</p></blockquote><p><span role="heading">Specific</span> Unambiguous, consistent and be at the appropriate level of detail.</p><blockquote><p>R001: The system should <ins>have a higher font screen in the internet
application to allow a visually impaired elderly person to upload blood
pressure and pulse rate.</ins></p></blockquote><p><span role="heading">Measurable</span> Possible to verify a requirement has been met so include success criteria.</p><blockquote><p>R001: The system should have a higher font screen <ins>compliant to
Accessibility Requirements for People with Low Vision</ins>in the internet
application to allow a visually impaired elderly person to upload blood
pressure and pulse rate.</p></blockquote><p><span role="heading">Attainable</span> Technically feasible and be within the art of the possible (also known as achievable).</p><blockquote><p>R001: The system should have a higher font screen compliant to Accessibility
Requirements for People with Low Vision in the internet application to allow a
visually impaired elderly person to upload blood pressure and pulse rate<ins>,
at least 90% of the time, and assuming all network services and interfacing
applications are operating as defined in the Project Assumptions &
Dependencies.</ins></p></blockquote><p><span role="heading">Realisable</span> Realistic given all the constraints defined (also known as repeatable).</p><blockquote><p>R001: The system should have a higher font screen compliant to Accessibility
Requirements for People with Low Vision in the internet application to allow a
visually impaired elderly person to upload blood pressure and pulse rate, at
least 90% of the time, and assuming all network services and interfacing
applications are operating as defined in the Project Assumptions &
Dependencies.<ins>This requirement will be delivered on time provided all
dependencies on infrastructure and resources are resolved as per the plan
outlined in the Project Assumptions & Dependencies.</ins></p></blockquote><p><span role="heading">Traceable</span> Linked from conception through specification, design, implementation and test.</p><blockquote><p>R001: The system should have a higher font screen <ins>no smaller than Arial 28px,</ins>
compliant to Accessibility Requirements for People with Low Vision
in the internet application to allow a visually impaired elderly person to
upload blood pressure and pulse rate, at least 90% of the time, and assuming
all network services and interfacing applications are operating as defined in
the Project Assumptions & Dependencies. This requirement will be delivered on
time provided all dependencies on infrastructure and resources are resolved as
per the plan outlined in the Project Assumptions & Dependencies.</p></blockquote><p><span role="heading">Testable</span> There must be acceptance criteria that aligns with expected business value and
converted to a specific test condition.</p><h2>Representations</h2><p>Requirement documentation can be very complex and thus difficult to read. By
decomposing requirements and expressing them in human-readable formats, the
subsequent processes (design, development, testing) can be tackled more easily.
It also reduces the likelihood of lost/misinterpreted requirements.</p><h3>Use Cases</h3><p>A <em>use case</em> describes how a system will be used, either though a list of actions or event steps by considering:</p><ul><li>Actor &mdash; Anyone or anything using the system</li><li>Stakeholder &mdash; Someone or something with vested interests in the behaviour of
the system</li><li>Primary Actor &mdash; Stakeholder who initiates an interaction with the system to
achieve a goal</li><li>Preconditions &mdash; What must be true or happen before and after the use case
runs.</li><li>Triggers &mdash; The event that causes the use case to be initiated.</li><li>Main Scenarios &mdash; Use case in which nothing goes wrong.</li><li>Alternative Paths &mdash; These paths are a variation on the main theme. These
exceptions are what happen when things go wrong at the system level</li></ul><h3>User Stories ❤️</h3><p>A <em>user story</em> describes a feature from an end-user's perspective. These features are very small, only further
decomposable into design/development/testing tasks.</p><p>They can be grouped together under an Epic, which describes a feature of the
application. Naturally, the feature described in a Epic is large.</p><p><span role="heading">Description</span> Specification of the user, what they want, and why. This is commonly formatted
like 'as [user], I want [a goal], so that [reasoning]'. It's highly preferable to use a persona as the user,
instead of (re)defining users across stories or referring to 'user' generically.</p><p>For example, a user story for 'Sam' (a 21-year-old Instagram user) could look
like 'As Sam, I want to login with my Facebook account, so that I don't need to
remember another password'.</p><p><span role="heading">Acceptance Criteria</span> A description of the expected functionality of the feature, covering
happy and sad paths. These are also written from a user's perspective, containing what has happened, what is about
to happen, and when should happen.</p><p>Using a behavioural format helps to maintain consistency, typically 'Given the
user..., when..., then...'</p><p>For example, a happy path could look like 'Given that Sam clicks the 'Sign in'
button, when he first opens the application, then he has the option to use
Facebook to log in'</p><p><span role="heading">Designs</span> Often they are exclusively for UI (sketches, wireframes, visual prototypes), but
new features may also specify the technical approach (e.g., an ERD).</p></main></body></html>