<!DOCTYPE html><html><head> <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png"><link rel="manifest" href="/icons/site.webmanifest"><link rel="shortcut icon" href="/icons/favicon.ico"><meta name="msapplication-TileColor" content="#603cba"><meta name="msapplication-config" content="/icons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="--WV6qAuzU9GnL3462uvvFCGbyR8jm9J0YzYWMWQ1IU"><title>Trees • joshsj</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><link rel="stylesheet" href="/styles/variables.css"><link rel="stylesheet" href="/styles/utilities.css"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/layout.css"><link rel="stylesheet" href="/styles/components.css"><link rel="stylesheet" href="/styles/lib.css"><script src="/scripts/theme.js" defer></script><script src="/scripts/myEmail.js" defer></script><script src="/scripts/id-jumper.js" defer></script><script src="/scripts/konami.js" defer></script></head><body>   <nav><a href="/">Home</a><a href="/blog/">Blog</a><a href="/collections/">Collections</a><a href="/portfolio/">Portfolio</a><button class="link" id="theme-toggle" aria-hidden="" aria-role="Toggle for light/dark theme"></button></nav><main class="content"><h1>Trees</h1><p>Posted on August 3rd, 2022</p><p class="squish">Updated on September 9th, 2022</p><p class="squish">Part of <a href="/collections/"> (Re)Learning CS</a></p><p class="squish sep sep-pop"><span class="skip">Talks about</span><span>Computer Science</span></p><p>Trees are a restricted subset of graphs.</p><!-- more--><p>To get to grips with the terminology, jump ahead to the basics of<a href="/(re)learning-cs/graphs/">graphs</a>.</p><iframe class="spotify space" src="https://open.spotify.com/embed/track/4iVTSRiJAA18d3QglhyJ6Q"></iframe><h2>Rooted Tree</h2><p>In a <em>rooted tree</em>, all nodes have a one parent with many children.
All above nodes are <em>ancestors</em> and all below nodes are <em>descendants</em>.</p><p>The single node at the top is the <em>root node</em> (no parents) and the nodes are the
bottom are <em>leaves</em> (no children). Any node with children is also an <em>internal node</em>.</p><figure><div class="inner"><img src="rooted tree.svg"></div><figcaption><a class="source" href="https://stepik.org/lesson/28726/step/4">Source</a>A rooted tree.</figcaption></figure><p>Rooted trees have an implicit hierarchical structure. With only one parent and
multiple children, they can be considered 'top-down'.</p><h2>Unrooted Tree</h2><p>In an <em>unrooted tree</em> , there is no notion of parents or children. A given node has
<em>neighbours</em>; any nodes with one neighbour is a <em>leaf</em> and any node with many
neighbours is an <em>internal node</em>.</p><figure><div class="inner"><img src="unrooted tree.svg"></div><figcaption><a class="source" href="https://stepik.org/lesson/28726/step/4">Source</a>An unrooted tree.</figcaption></figure><p>Unrooted trees do not have an implicit hierarchy. They can be interpreted
as 'outside-in', where only the relationships from lead to internal node are
considered , or vice versa with 'inside-out'.</p><h2>Binary Tree</h2><p>A <em>binary tree</em> is a rooted tree with these constraints:</p><ul><li>All nodes have a parent except the root</li><li>All nodes have either 0, 1, or 2 children</li></ul><p>Generally, we only maintain a pointer to the root node and access its children
programmatically. Maintaining pointers to children is possible but complex, as
the structure changes.</p><figure><div class="inner"><img src="binary tree.svg"></div><figcaption><a class="source" href="https://stepik.org/lesson/28726/step/8">Source</a>A binary tree.</figcaption></figure><p>We can further consider a binary tree as <em>full</em>, meaning every node has two
children, excluding the leaves; or <em>complete</em>, meaning every level, but possibly
the last, is completely filled and all nodes are to leftmost.</p><p>To make the diagram above complete, 8 would become the right child of 3 and 9
would become the left child of 4. To make it full, 5 and 6 would need two
children (or 7, 8, and 9 would need removing).</p><h3>Traversal</h3><p>We have four algorithms to remember! All of which are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>
cos every node is visited.</p><table><thead><tr><th>Algorithm</th><th>Order</th><th>Example</th></tr></thead><tbody><tr><td>Pre-order</td><td>Visit Left Right</td><td><code>0 1 3 7 4 2 5 8 6 9</code></td></tr><tr><td>In-order</td><td>Left Visit Right</td><td><code>7 3 1 4 0 5 8 2 6 9</code></td></tr><tr><td>Post-order</td><td>Left Right Visit</td><td><code>7 3 4 1 8 5 9 6 2 0</code></td></tr><tr><td>Level-order</td><td>Visit each level</td><td><code>0 1 2 3 4 5 6 7 8 9</code></td></tr></tbody></table><h2>Heap</h2><p>A heap is a tree that satisfies the <em>heap property</em>: a parent node means higher
priority. A binary heap must also satisfy the binary tree constraints and be <em>complete</em>.</p><p>Within the world of heaps, we firstly have <strong>min-heaps</strong>, in which a parent node
has a lesser-or-equal value to all of its children. That is, a smaller value means higher priority.
A <strong>max-heap</strong> is the opposite.</p><figure><div class="inner"><img src="min max heap.svg"></div><figcaption><a class="source" href="https://stepik.org/lesson/28863/step/4">Source</a>A min and max-heap.</figcaption></figure><p>It is also valid for duplicate node values in a heap &mdash; two things can have the
same priority.</p><h2>Binary Search Tree</h2><p>A <em>Binary Search Tree (BST)</em> allows arbitrary values to be found fairly quickly.
It's structured as a rooted binary tree, where every node is greater than all
nodes to its left and less than all to its right. Inherently, only comparable
types can be stored in a BST.</p><figure><div class="inner"><img src="bst.svg"></div><figcaption><a class="source" href="https://stepik.org/lesson/28727/step/1">Source</a>A binary search tree.</figcaption></figure><p>The <em>height</em> of a BST is the longest distance from the root of the tree to a
leaf; a tree with no nodes has a height of -1, only a root has a height of 0,
and a node+leaf has a height of 1, etc.</p><p>We can also consider the balance of a BST. When balanced, most leaves are
equidistant from the root and most internal nodes have two children. When <strong>perfectly</strong>
balanced, it's all of em.</p><p>Unbalanced trees are also a thing.</p><figure><div class="inner"><img src="perfectly balanced bst.svg"></div><figcaption><a class="source" href="https://stepik.org/lesson/28727/step/9">Source</a>A perfectly balanced BST.</figcaption></figure><p>The average-case time complexity to find an element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>;
there is a proof, but it's <a href="https://stepik.org/lesson/28730/step/4">fucking mental</a>.</p><h2>Implementations</h2><!-- TODO add link to implementations--><p>Generally, implementing a tree structure involves a <code>Node</code> object containing a
value and child pointers &mdash; an array for normal trees, <code>left</code> and <code>right</code>
properties for binary trees.</p><figure><div class="inner"><img src="heap array.png"></div><figcaption><a class="source" href="https://stepik.org/lesson/28863/step/11">Source</a>A heap structured with an array.</figcaption></figure><p>Alternatively, we can utilise pointer arithmetic to store binary trees in<a href="/(re)learning-cs/lists/#Array">arrays</a>. The start of
the array represents the tree root and the following formulae can access nodes
relative to an index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>:</p><ul><li>Parent: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mrow><mi>I</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\frac{I-1}{2}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></li><li>Left Child: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>Right Child: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2i+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></li></ul></main></body></html>