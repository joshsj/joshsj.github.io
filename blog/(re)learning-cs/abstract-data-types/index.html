<!DOCTYPE html><html><head> <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png"><link rel="manifest" href="/icons/site.webmanifest"><link rel="shortcut icon" href="/icons/favicon.ico"><meta name="msapplication-TileColor" content="#603cba"><meta name="msapplication-config" content="/icons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="--WV6qAuzU9GnL3462uvvFCGbyR8jm9J0YzYWMWQ1IU"><title>Abstract Data Types ‚Ä¢ joshsj</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><link rel="stylesheet" href="/styles/variables.css"><link rel="stylesheet" href="/styles/utilities.css"><link rel="stylesheet" href="/styles/base.css"><link rel="stylesheet" href="/styles/layout.css"><link rel="stylesheet" href="/styles/components.css"><link rel="stylesheet" href="/styles/lib.css"><script src="/scripts/theme.js" defer></script><script src="/scripts/myEmail.js" defer></script><script src="/scripts/id-jumper.js" defer></script><script src="/scripts/konami.js" defer></script></head><body>   <nav><a href="/">Home</a><a href="/blog/">Blog</a><a href="/collections/">Collections</a><a href="/portfolio/">Portfolio</a><button class="link" id="theme-toggle" aria-hidden="" aria-role="Toggle for light/dark theme"></button></nav><main class="content"><h1>Abstract Data Types</h1><p>Posted on August 3rd, 2022</p><p class="squish">Part of <a href="/collections/"> (Re)Learning CS</a></p><p class="squish sep sep-pop"><span class="skip">Talks about</span><span>Computer Science</span></p><p>Producing software with a real-world purpose means translating a high-level
problem into something computational. When considering its data, we don't
immediately jump to <code>CREATE TABLE</code>; we start by considering what data
is needed, how it relates, and how we can represent it.</p><p>For example, we can represent a Person with a <code>Map</code>, with keys to identify
something about them and corresponding values. More technically, we can model a
<code>List</code> data type with the functions <code>insert</code>, <code>find</code>, <code>reduce</code>
without specifying it as an array or linked list.</p><p> An <em>Abstract Data Type (ADT)</em> is <!-- excerpt-->a model for a data type defined
by its behaviour from the perspective of a consumer, not its
implementation.<!-- excerpt--></p><p>Basically, it's what it does, not how it does it.</p><h2>Double-Ended Queue</h2><p>Think of browser history (üò¨). Values are added and removed from the front as
navigation moves forwards and backwards; to limit its size, the oldest values
are removed from the back.</p><p>The <em>double-ended queue</em> ADT (or dequeue, or deque, pronounced 'deck') is 
generally defined with:</p><ul><li><code>addFront(x)</code></li><li><code>addBack(x)</code></li><li><code>peekFront()</code></li><li><code>peekBack()</code></li><li><code>removeFront()</code></li><li><code>removeBack()</code></li><li><code>size()</code></li></ul><p> Both a <a href="/(re)learning-cs/lists/#Circular-Array">circular array</a> 
and a <a href="/(re)learning-cs/lists/#Linked-List">linked list</a>
can implement a deque. Neither is perfect, as they are both 
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> when inserting and indexing/searching respectively.</p><p>The following structures can also use a deque as a backing structure.</p><h2>Queue</h2><p>Think of a queue. Values are only added to the back and are only removed from
the front, making it <em>first in, first out (FIFO)</em>.</p><p>A <em>queue</em> is a generally defined with:</p><table><thead><tr><th>Function</th><th>Using Deque</th></tr></thead><tbody><tr><td><code>enqueue(x)</code></td><td><code>addBack(x)</code></td></tr><tr><td><code>peek()</code></td><td><code>peekFront()</code></td></tr><tr><td><code>dequeue()</code></td><td><code>removeFront()</code></td></tr></tbody></table><h2>Stack</h2><p>Think a pile of plates ready for the washing up. Values are added <strong>and</strong> 
removed to the front, making it <em>last in, first out (LIFO)</em>.</p><p>A <em>stack</em>is generally defined with:</p><table><thead><tr><th>Function</th><th>Using Deque</th></tr></thead><tbody><tr><td><code>push(x)</code></td><td><code>addFront(x)</code></td></tr><tr><td><code>peek()</code></td><td><code>peekFront()</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFront()</code></td></tr></tbody></table><h2>Priority Queue</h2><p>Think of the queue in A&E. It's still FIFO but the elements are reordered by
their priority, making it <em>highest priority in, first out (HPIFO)</em>.</p><p>A <em>priority queue</em> is generally defined with:</p><ul><li><code>insert(x)</code></li><li><code>peek()</code></li><li><code>pop()</code></li></ul><p>Implementing a priority queue with a list structure realises an issue: a sorted
linked list would result in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> to peek and remove, but <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> to
insert into a sorted position. An unsorted linked list swaps the time
complexities and array implementations suffer the same pain.</p><p>Instead we can use a <a href="/blog/(re)learning-cs/trees/">heap</a>, giving us <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>to peek and<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>‚Å°</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>to insert/remove.</p><h2>Map</h2><p>There's lots of associated data: a students name and their grade, a customer's
account number and their balance, etc.</p><p> A <em>map</em> uses a <em>key</em> to identify data and a <em>value</em> to store the data. 
They are generally defined with</p><ul><li><code>put(key, value)</code></li><li><code>get(key)</code></li><li><code>remove(key)</code></li><li><code>size()</code></li><li><code>has(key)</code></li></ul><p>When inserting a duplicate key, the value is generally overwritten but C++
deviates from this with its <code>unordered_map()</code>.</p><p>We can implement maps with many data structures but random lookup is often
prioritised by using <a href="/blog/(re)learning-cs/hashing/">hash maps</a>. 
That said, a <a href="/blog/(re)learning-cs/trees/">binary search tree</a>
could keep the keys ordered while sacrificed that sweet sweet constant
lookup time complexity of a hash map.</p></main></body></html>